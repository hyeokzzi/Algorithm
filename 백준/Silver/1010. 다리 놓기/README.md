# [Silver V] 다리 놓기 - 1010 

[문제 링크](https://www.acmicpc.net/problem/1010) 

### 성능 요약

메모리: 2024 KB, 시간: 20 ms

### 분류

조합론, 다이나믹 프로그래밍, 수학

### 문제 설명

<p>재원이는 한 도시의 시장이 되었다. 이 도시에는 도시를 동쪽과 서쪽으로 나누는 큰 일직선 모양의 강이 흐르고 있다. 하지만 재원이는 다리가 없어서 시민들이 강을 건너는데 큰 불편을 겪고 있음을 알고 다리를 짓기로 결심하였다. 강 주변에서 다리를 짓기에 적합한 곳을 사이트라고 한다. 재원이는 강 주변을 면밀히 조사해 본 결과 강의 서쪽에는 N개의 사이트가 있고 동쪽에는 M개의 사이트가 있다는 것을 알았다. (N ≤ M)</p>

<p>재원이는 서쪽의 사이트와 동쪽의 사이트를 다리로 연결하려고 한다. (이때 한 사이트에는 최대 한 개의 다리만 연결될 수 있다.) 재원이는 다리를 최대한 많이 지으려고 하기 때문에 서쪽의 사이트 개수만큼 (N개) 다리를 지으려고 한다. 다리끼리는 서로 겹쳐질 수 없다고 할 때 다리를 지을 수 있는 경우의 수를 구하는 프로그램을 작성하라.</p>

<p><img alt="" src="https://www.acmicpc.net/upload/201003/pic1.JPG" style="height:353px; width:329px"></p>

### 입력 

 <p>입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수 정수 N, M (0 < N ≤ M < 30)이 주어진다.</p>

### 출력 

 <p>각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.</p>



### 풀이과정
## 내 풀이

수학적인 공식을 생각하기보다는 DP 관련 문제이기 때문에 결과를 저장하고 그것을 반복적으로 이용하여 문제를 해결하는 방법만 생각하였었다.

내가 생각한 문제 풀이 방식은 다음과 같다.

```python
int dp(int x, int y) {
	if (x == y) return 1;
	if (x == 1) return y;
	int sum = 0;
	for (int i = 1; i <= y - x + 1; i++) {
		sum += dp(x - 1, y - i);
	}
	return sum;
}
```

강 서쪽의 사이트들은 모두 연결되어야 하므로 맨 위 사이트부터 강 동쪽의 사이트와 연결해야한다.

그러므로 강 서쪽 맨 위에 있는 사이트는 강 동쪽에 있는 사이트중 자신을 제외한 나머지 사이트의 갯수를 제외한 나머지 이다. 

( ex 강 서쪽 사이트 5개 강 동쪽 사이트 9개인 경우 강 서쪽의 맨 위 사이트가 최대로 선택할 수 있는 사이트는 9-4 = 5개 이다. )

이러한 방식을 생각해서 반복적인 수식을 만들면 강 동쪽의 첫 번째 사이트를 선택한 경우부터 다섯번째 사이트를 선택한 경우를 모두 더해야 한다.

즉, x와 y의 차이만큼을 반복하며 더해야 하므로 다음과 같은 수식이 완성된다.

수식 : `sum += dp(x-1,y-i);` 

이렇게 반복하여 계산하면 `x==y` 와 `x==1` 를 만나 return 값이 생기면서 축적하여 정답을 도출해 낸다.

### 문제점

따로 저장을 하지 않았기 때문에 속도면에서 문제가 생겨 시간초과로 오답이 된다.

아래와 같이 수정을 하여 30x30 배열을 만들고 값을 저장하여 if문을 통해 배열 값이 0이 아닌 경우에는 반환을 하도록 하면 시간 문제가 해결되어 정답 처리 될 것이다.

```python
int arr[30][30];
int dp(int x, int y) {

	if (x == y) return 1;
	if (x == 1) return arr[x][y] = y;
	if (arr[x][y] != 0) return arr[x][y];
	int sum = 0;
	for (int i = 1; i <= y - x + 1; i++) {
		sum += dp(x - 1, y - i);
	}
	return arr[x][y] = sum;
}
```

## 정석 풀이

경우의 수를 구하는 데에는 순열, 조합, 중복 순열 등이 있다.

그 중에서도 이 문제에 적용되는 것은 순서가 적용 되지 않기 때문에 **조합**을 사용한다.

조합에서 가장 많이 사용하는 공식으로 

`nCr = n-1Cr-1 + n-1Cr` 이 있다.

어떻게 보면 DP의 정석 문제인 피보나치 수열에 `f(n) = f(n-1) + f(n-2)` 와 같은 반복하는 연산 공식이다.

조합 공식 이용하는 것이 이 **문제의 핵심**이다.

함수를 통해 조합 공식을 구현하면 아래와 같다.

```python
int arr[30][30] = { 0, };
int dp_combination(int x, int y) {
	
	if (x == y || x == 0) return 1;
	else if (arr[x][y] != 0) return arr[x][y];
	else {
		return arr[x][y] = dp_combination(x - 1, y - 1) + dp_combination(x, y - 1);
	}
}
```

조합 nCr에서 r이 0이거나 n과 같다면 1이 나오는 점을 이용하여 값이 계속 쌓여가는 형태로 진행된다.
