# [Silver III] 퇴사 - 14501 

[문제 링크](https://www.acmicpc.net/problem/14501) 

### 성능 요약

메모리: 2020 KB, 시간: 0 ms

### 분류

브루트포스 알고리즘, 다이나믹 프로그래밍

### 문제 설명

<p>상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.</p>

<p>오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.</p>

<p>백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.</p>

<p>각각의 상담은 상담을 완료하는데 걸리는 기간 T<sub>i</sub>와 상담을 했을 때 받을 수 있는 금액 P<sub>i</sub>로 이루어져 있다.</p>

<p>N = 7인 경우에 다음과 같은 상담 일정표를 보자.</p>

<table class="table table-bordered">
	<thead>
		<tr>
			<th> </th>
			<th>1일</th>
			<th>2일</th>
			<th>3일</th>
			<th>4일</th>
			<th>5일</th>
			<th>6일</th>
			<th>7일</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th>T<sub>i</sub></th>
			<td>3</td>
			<td>5</td>
			<td>1</td>
			<td>1</td>
			<td>2</td>
			<td>4</td>
			<td>2</td>
		</tr>
		<tr>
			<th>P<sub>i</sub></th>
			<td>10</td>
			<td>20</td>
			<td>10</td>
			<td>20</td>
			<td>15</td>
			<td>40</td>
			<td>200</td>
		</tr>
	</tbody>
</table>

<p>1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.</p>

<p>상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.</p>

<p>또한, N+1일째에는 회사에 없기 때문에, 6, 7일에 있는 상담을 할 수 없다.</p>

<p>퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.</p>

<p>상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.</p>

<p>둘째 줄부터 N개의 줄에 T<sub>i</sub>와 P<sub>i</sub>가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ T<sub>i</sub> ≤ 5, 1 ≤ P<sub>i</sub> ≤ 1,000)</p>

### 출력 

 <p>첫째 줄에 백준이가 얻을 수 있는 최대 이익을 출력한다.</p>


## 문제 풀이

문제를 봤을 때 입력할 수 있는 N이 최대 15라고 해서 재귀방법을 사용하여 Top-down 식으로 풀려고 하였다.

하지만 최악의 경우 $2^n$번 확인하는 것 보다는 $N$번 확인하는 것이 더 효율적이라고 판단되어 Bottom-up방식으로 문제를 해결하였다.

유의해야 할 조건은 두가지였다.

1. 퇴사일을 넘기지 말 것
2. 최대치를 찾는 것

입력받은 값의 앞에서부터 접근을 하면 발생하는 문제는 **축적이라는 개념이 사라진다**는 것이었다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8f739e7-50cb-4e40-9458-d3c99649d064/Untitled.png)

다음과 같이 N이 7이고 값들이 주어졌다고 하자. 계산을 다음과 같이 진행 할 것이다.

1일꺼부터 시작 : (1일)3일짜리 상담 +(4일)1일짜리상담 + (5일)2일짜리 상담 

2일꺼부터 시작 : (2일)5일짜리 상담

이런식으로 문제를 접근하게 되면 최댓값을 찾기 어려울 뿐만아니라 조건과 연산만 늘어난다.

그래서 `남은 일수`를 기준으로 접근했다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/25c51e80-6788-4bb4-9de9-557f1324d10c/Untitled.png)

위 표와 같이 인덱스를 남은 일수를 기준으로 배열의 최댓값들을 저장하는 방식이다.

유의할 점은 2가지이다.

1. 퇴사일을 넘기지 말것
2. 최대치를 찾을 것 → 연산을 진행한 후 비교할 것

```cpp
for (int i = 1; i <= N; i++) {         // i는 남은 일 수
		int T = arr[N - i].first;
		int P = arr[N - i].second;
		if (i >= T) {
			dp[i] = std::max(P + dp[i - T], dp[i - 1]);
		}
		else {
			dp[i] = dp[i - 1];
		}
	}
```

남은 일수를 가지고 자신이 가질 수 있는 최댓값을 찾는 것이다.

유의사항 1번을 남은 일수와 그 날의 상담의 진행기간을 비교하는 것을 통해 해결했다.

만약, 남은 일수가 진행기간보다 작다면 그 일은 진행하지 못한다. 

그러므로 가능한 것만 생각하여 다음과 같은 연산을 진행한다.

`P + dp[i - T]`

해석해보면 그 날의 상담일정을 소화하고 남은 일수로 상담해서 벌 수 있는 최댓값을 더하는 것이다.

(왜 dp[i-T]인가? → 최댓값을 축적하는 것으로 가정했기 때문에)

이 과정을 거친 후, 하나의 과정이 더 필요하다. 바로 **`유의사항 2번 진짜 최대인지 확인`**하는 것이다.

가정한대로 dp배열의 자신 인덱스 이전값은 자신의 최댓값일 것이다. 이 값과 비교를 진행해야 한다.

문제가 발생되는 예시는 다음과 같다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/873a51a4-d0ba-4e8f-8f07-4cb0104bb115/Untitled.png)

위 표와 같이 4일차의 상담을 진행할 경우 7일차와의 상담을 더한 최댓값이 50일 것이다.

하지만 5일차의 저장되어있는 최댓값(dp[3])이 그 값을 넘어선다.

그렇기 때문에 다음과 같은 연산을 비교한다.

`dp[i] = std::max(P + dp[i - T], dp[i - 1]);`

이 연산을 통해 dp[i]에 저장되는 값은 최댓값인 70으로 저장될 것이다.

## 최종 코드

```cpp
#include<iostream>
#include<vector>
std::vector<std::pair<int, int>> arr;

int main() {
	int N;
	std::cin >> N;
	for (int i = 0; i < N; i++) {
		int num1, num2;
		std::cin >> num1 >> num2;
		arr.push_back(std::make_pair(num1, num2));
	}

	int dp[16] = { 0, };
	for (int i = 1; i <= N; i++) {
		int T = arr[N - i].first;
		int P = arr[N - i].second;
		if (i >= T) {
			dp[i] = std::max(P + dp[i - T], dp[i - 1]);
		}
		else {
			dp[i] = dp[i - 1];
		}
	}
	std::cout << dp[N];
	return 0;
}
```
