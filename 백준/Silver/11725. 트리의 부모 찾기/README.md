# [Silver II] 트리의 부모 찾기 - 11725 

[문제 링크](https://www.acmicpc.net/problem/11725) 

### 성능 요약

메모리: 10060 KB, 시간: 44 ms

### 분류

그래프 이론(graphs), 그래프 탐색(graph_traversal), 트리(trees), 너비 우선 탐색(bfs), 깊이 우선 탐색(dfs)

### 문제 설명

<p>루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.</p>

### 출력 

 <p>첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.</p>


# 문제 풀이
문제를 통해 얻을 수 있는 정보는 다음과 같다.   
> 1.  1번을 루트로 하는 트리구조를 이용한 문제
> 2.  최대 10만개의 입력가능하기에 메모리 사용과 처리시간의 유의
   
문제를 해석해보면 노드간의 연결정보를 이용하여   
최종적으로 ***각 노드의 부모노드 정보***를 가지고 있는 ***배열***이 결과물로 있어야 한다.   

최대 10만개의 입력을 받아서 ***그래프 탐색***을 방식으로 처리하는 것은 ***처리시간에 문제***가 발생할 것이다.   
그렇기 때문에 연결 정보를 저장하여 ***1번 루트***부터 ***내려가는 방식***으로 진행하여야 한다고 판단했다.   


먼저 단순한 1차원 배열의 연결된 노드의 정보를 저장하기에는 자식노드의 수가 하나가 아닌 여러개라는 점에서 문제가 생긴다.   
그렇기 때문에 배열의 원소들은 각각 연결된 노드의 정보를 저장하는 배열을 가져야 한다.   

이를 해결하기 위해 `vector`와 `구조체`를 이용하여서 해결하였다.
```c++
typedef struct node{
 std::vector<int> arr;
}node;
```   

위 구조체의 인수로 가지는 배열`node connect[100001]`을 사용하여 다음과 같은 구조로 사용하고자 하였다.
```
n번 노드 : connect 배열의 index
n번 노드와 연결된 노드 정보 : vector형태의 배열
```   

최종적으로 입력을 받을 때 각각의 노드가 연결정보를 가질 수 있도록하였다.
```c++
for (int i = 0; i < N-1; i++) {
	int num1, num2;
	std::cin >> num1 >> num2;
	connect[num1].arr.push_back(num2);
	connect[num2].arr.push_back(num1);
}
```   

우리가 가지고 있는 정보는 두 가지이다.
> 1. 노드간의 연결 정보
> 2. 루트는 1번이다.   

이것을 이용하는 방법으로는 `DFS` 방식을 이용하여 `재귀함수`를 통해 해결하고자 하였다.
흐름은 다음과 같다.
1. 1과 연결된 노드(n)를 찾는다.
2. 1과 연결된 노드(n)의 부모노드 정보를 1로 설정 (부모노드 정보를 가지는 배열에 저장)
3. n를 재귀함수의 인자로 넣어 함수 호출
4. n과 연결된 노드를 찾아 부모노드 정보를 n으로 설정
   
하지만, arr배열이 가지고 있는 연결 정보에는 `부모노드와의 연결정보`도 가지고 있기 때문에   
`부모노드의 정보가 없는 노드`들만 처리하도록 ***재귀함수 내부에서 해결***해줘야 한다.

부모노드의 정보를 저장하는 `head`배열을 이용하여 `if문`을 통해 0인 노드만 처리한다. 
```c++
void find_head(int head_num) {
	for (auto& e : connect[head_num].arr) {
		if (head[e] == 0) {
			head[e] = head_num;
			find_head(e);
		}
	}
	return;
}
```   

최종적으로 위 재귀함수를 통해 `DFS`방식으로 해결하였다.   
트리 전체를 이동하여 부모노드의 정보를 얻어가는 방식이기 때문에 `BFS`를 이용해서 해결 할 수도 있다.
