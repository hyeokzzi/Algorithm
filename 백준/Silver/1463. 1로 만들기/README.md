# [Silver III] 1로 만들기 - 1463 

[문제 링크](https://www.acmicpc.net/problem/1463) 

### 성능 요약

메모리: 5928 KB, 시간: 4 ms

### 분류

다이나믹 프로그래밍

### 문제 설명

<p>정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.</p>

<ol>
	<li>X가 3으로 나누어 떨어지면, 3으로 나눈다.</li>
	<li>X가 2로 나누어 떨어지면, 2로 나눈다.</li>
	<li>1을 뺀다.</li>
</ol>

<p>정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.</p>

### 입력 

 <p>첫째 줄에 1보다 크거나 같고, 10<sup>6</sup>보다 작거나 같은 정수 N이 주어진다.</p>

### 출력 

 <p>첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.</p>

## 내 풀이

DP와 관련된 문제이기 때문에 재귀함수를 사용하여 문제를 해결하고자 하였다.

```python
void dp(int N, int count) {
	if (count > min_count) return;
	if (N == 1) {
		if (min_count > count) {
			min_count = count;
		}
		return;
	}
	if (N % 3 == 0) dp(N / 3, count + 1);
	if (N % 2 == 0) dp(N / 2, count + 1);
	dp(N - 1, count + 1);
	return;
}
```

함수를 시작할 때 두 가지 탈출 조건을 만들어 주었다. 

1. 현재 실행되고 있는 재귀함수의 인자인 count가 이미 나온 결과의 count보다 클 경우
    - 최소한의 실행 횟수보다 크면 다음으로 진행하는 것은 의미가 없기 때문
2. 목표의 도달하였을 경우

두 가지 조건을 지났을 경우는 문제가 해결중인 과정이므로 문제의 조건인 3가지 처리과정을 거치도록 하였다.

DFS와 비슷한 풀이방법으로 모든 조건을 들어가면서 최소한의 count를 찾는 과정으로 문제를 해결하였다.

## 정석풀이

문제의 풀이 의도는 DP를 사용함과 동시에 Bottom-up 방법으로 문제를 해결하는 것을 의도하였다.

반복문을 이용하여 1이 되도록하는 최소값을 찾는 과정이다.

```python
for (int i = 2; i <= N; i++) {
		dp[i] = dp[i - 1] + 1;
		if (i % 3 == 0) dp[i] = std::min(dp[i], dp[i / 3] + 1);
		if (i % 2 == 0) dp[i] = std::min(dp[i], dp[i / 2] + 1);
	}
```

기본적으로 이전 배열의 값의 +1 한 것이 최솟값이라는 것을 가정하에 반복문을 진행하고, 3의 배수이거나 2의 배수일 경우에는 최솟값으 비교하여 저장하는 방식으로 문제를 해결한다.

## 배운점

DP의 문제풀이의 기본형식은 재귀함수라고 생각하였다.

```python
int dp[100];
int fibo(int n) {
	if (n == 1 || n == 2) return 1;
	else if (dp[n] != 0) return dp[n];
	else return dp[n] = fibo(n - 1) + fibo(n - 2);
}
```

피보나치 수열을 해결하는 과정에서 재귀함수를 통해서 문제를 해결하는 것을 DP의 기본 원리라고 생각하였다. 하지만 Bottom-up 방식으로 진행하는 것도 하나의 DP 문제 풀이 방법이였다.

- DP의 Bottom-up 방식 - 반복문을 이용한다.

```python
int dp[100] = { 0, 1, 1 };
for (i = 3; i <= n; i++) {
	dp[i] = dp[i - 2] + dp[i - 1];
}
```

반복문을 통해 값을 전달하며 쌓아가는 방식으로 메모리와 시간을 절약할 수 있다고 한다.
